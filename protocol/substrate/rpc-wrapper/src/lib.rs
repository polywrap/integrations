// TODO: documentation
// #![deny(warnings)]
// #![warn(missing_docs)]

// The `wrap` module is autogenerated and will produce warnings.
// Allow them since we can't change the code
#[allow(warnings)]
pub mod wrap;

pub use api::Api;
use api::BaseApi;

use codec::{Compact, Encode};
pub use error::Error;
use num_traits::cast::FromPrimitive;
use polywrap_wasm_rs::BigNumber;
use scale_info::{TypeDef, TypeDefPrimitive};
use sp_core::{crypto::{AccountId32, Ss58Codec}, sr25519::Signature};

use crate::{
    types::{
        account_info::MultiAddress, extrinsic_params::ExtrinsicParams,
        extrinsics::UncheckedExtrinsicV4,
    },
    utils::Encoded,
};
pub use types::metadata::Metadata;
use wrap::imported::*;
pub use wrap::{
    imported::{
        SignerProviderSignerPayloadJSON as ExtrinsicPayload,
        SignerProviderSignerPayloadRaw,
    },
    *,
};
use sp_runtime::MultiSignature;

mod api;
mod error;
mod types;
mod utils;

/// Wraps the signer-provider getAccounts function
/// Returns a list of the accounts managed by the host
pub fn get_signer_provider_accounts(
    _args: ArgsGetSignerProviderAccounts,
) -> Vec<SignerProviderAccount> {
    SignerProviderModule::get_accounts(
        &signer_provider_module::ArgsGetAccounts {},
    )
    .unwrap()
}

/// Retrieve the chain metadata via the `state_getMetadata` RPC
pub fn chain_get_metadata(
    ArgsChainGetMetadata { url }: ArgsChainGetMetadata,
) -> Option<ChainMetadata> {
    let metadata = BaseApi::new(&url).fetch_metadata();
    let meta = metadata.ok().flatten().expect("must have a metadata");

    let meta_json =
        serde_json::to_value(meta.metadata).expect("unable to convert to json");
    let pallet_json =
        serde_json::to_value(meta.pallets).expect("unable to convert to json");

    let events = meta.events.into_values().collect::<Vec<_>>();
    let events_json =
        serde_json::to_value(events).expect("unable to convert to json");
    let errors = meta.errors.into_values().collect::<Vec<_>>();
    let errors_json =
        serde_json::to_value(errors).expect("unable to convert to json");

    Some(ChainMetadata {
        metadata: meta_json,
        pallets: pallet_json,
        events: events_json,
        errors: errors_json,
    })
}

/// return the runtime version via the `state_getRuntimeVersion` RPC
pub fn get_runtime_version(
    ArgsGetRuntimeVersion { url }: ArgsGetRuntimeVersion,
) -> Option<RuntimeVersion> {
    BaseApi::new(&url)
        .fetch_runtime_version()
        .ok()
        .flatten()
        .map(|v| RuntimeVersion {
            spec_name: v.spec_name.to_string(),
            impl_name: v.impl_name.to_string(),
            authoring_version: v.authoring_version,
            spec_version: v.spec_version,
            impl_version: v.impl_version,
            transaction_version: v.transaction_version,
            state_version: v.state_version,
        })
}

/// return the rpc methods exposed in this chain
pub fn rpc_methods(
    ArgsRpcMethods { url }: ArgsRpcMethods,
) -> Option<Vec<String>> {
    BaseApi::new(&url).fetch_rpc_methods().ok().flatten()
}

/// return the block hash of a block with the specified block number `number`.
pub fn block_hash(
    ArgsBlockHash { url, number }: ArgsBlockHash,
) -> Option<String> {
    let api = BaseApi::new(&url);
    let block_hash = api.fetch_block_hash(number);
    block_hash.ok().flatten().map(|h| format!("{:#x}", h))
}

/// return the genesis_hash
pub fn genesis_hash(
    ArgsGenesisHash { url }: ArgsGenesisHash,
) -> Option<String> {
    let api = BaseApi::new(&url);
    let block_hash = api.fetch_genesis_hash();
    block_hash.ok().flatten().map(|h| format!("{:#x}", h))
}

/// return the Block at number
pub fn chain_get_block(
    ArgsChainGetBlock { url, number }: ArgsChainGetBlock,
) -> Option<BlockOutput> {
    let api = BaseApi::new(&url);
    let block = api.fetch_opaque_block(number);
    block.ok().flatten().map(|block| BlockOutput { block })
}

/// return value of storage from a module and storage name
///
/// `pallet` the pallet or module the storage belongs to.
/// `storage` The storage identifier to retrieve all values of
pub fn get_storage_value(
    ArgsGetStorageValue {
        url,
        pallet,
        storage,
    }: ArgsGetStorageValue,
) -> Option<Vec<u8>> {
    if let Ok(api) = Api::new(&url) {
        api.fetch_opaque_storage_value(&pallet, &storage)
            .ok()
            .flatten()
    } else {
        None
    }
}

/// Get the value in bytes from a storage map from a pallet with the specified `key`.
///
/// `pallet` the pallet or module the storage belongs to.
/// `storage` The storage map identifier
/// `key` The key into the storage map
pub fn get_storage_map(
    ArgsGetStorageMap {
        url,
        pallet,
        storage,
        key,
    }: ArgsGetStorageMap,
) -> Option<Vec<u8>> {
    Api::new(&url)
        .ok()
        .map(|api| {
            let (key_type, _value_type) = api
                .storage_map_type(&pallet, &storage)
                .ok()
                .flatten()
                .expect("must have a type");

            if let TypeDef::Primitive(primitive) = key_type.type_def() {
                //TODO: make this exhaustive to support i8,i16,i32,i64,i128 and u8,u16,u32,u64,u128
                match primitive {
                    TypeDefPrimitive::U32 => {
                        assert!(key.is_number());
                        let key =
                            key.as_u64().expect("must cast to u64") as u32;
                        api.fetch_opaque_storage_map(&pallet, &storage, key)
                            .ok()
                            .flatten()
                    }
                    TypeDefPrimitive::U64 => {
                        assert!(key.is_number());
                        let key =
                            key.as_u64().expect("must cast to u64") as u64;
                        api.fetch_opaque_storage_map(&pallet, &storage, key)
                            .ok()
                            .flatten()
                    }
                    TypeDefPrimitive::U128 => {
                        assert!(key.is_number());
                        let key =
                            key.as_u64().expect("must cast to u64") as u128;
                        api.fetch_opaque_storage_map(&pallet, &storage, key)
                            .ok()
                            .flatten()
                    }
                    _ => unimplemented!(),
                }
            } else {
                //TODO: this should be error for UnSupported key type
                None
            }
        })
        .flatten()
}

/// Get a the storage value in bytes from a storage map of the specified pallet.
///
/// `pallet` the pallet or module the storage belongs to.
/// `storage` The storage map identifier
/// `count` the number of items to be returned
/// `next_to` an optional `key` for storage map as a marker for the offset of the returned data.
pub fn get_storage_map_paged(
    ArgsGetStorageMapPaged {
        url,
        pallet,
        storage,
        count,
        next_to,
    }: ArgsGetStorageMapPaged,
) -> Option<Vec<Vec<u8>>> {
    Api::new(&url)
        .ok()
        .map(|api| {
            let (key_type, _value_type) = api
                .storage_map_type(&pallet, &storage)
                .ok()
                .flatten()
                .expect("must have a type");

            if let TypeDef::Primitive(primitive) = key_type.type_def() {
                //TODO: make this exhaustive to support i8,i16,i32,i64,i128 and u8,u16,u32,u64,u128
                match primitive {
                    TypeDefPrimitive::U32 => {
                        let next_to = next_to
                            .map(|k| k.as_u64().map(|k| k as u32))
                            .flatten();
                        api.fetch_opaque_storage_map_paged(
                            &pallet, &storage, count, next_to,
                        )
                        .ok()
                        .flatten()
                    }
                    TypeDefPrimitive::U64 => {
                        let next_to = next_to
                            .map(|k| k.as_u64().map(|k| k as u64))
                            .flatten();
                        api.fetch_opaque_storage_map_paged(
                            &pallet, &storage, count, next_to,
                        )
                        .ok()
                        .flatten()
                    }
                    TypeDefPrimitive::U128 => {
                        let next_to = next_to
                            .map(|k| k.as_u64().map(|k| k as u128))
                            .flatten();
                        api.fetch_opaque_storage_map_paged(
                            &pallet, &storage, count, next_to,
                        )
                        .ok()
                        .flatten()
                    }
                    _ => unimplemented!(),
                }
            } else {
                None
            }
        })
        .flatten()
}

/// return the constant value from a pallet
///
/// `pallet` the pallet or module the storage belongs to.
/// `name` Name of the constant
pub fn constant(
    ArgsConstant { url, pallet, name }: ArgsConstant,
) -> Option<Vec<u8>> {
    Api::new(&url)
        .ok()
        .map(|api| api.fetch_constant_opaque_value(&pallet, &name).ok())
        .flatten()
}

/// Get the account information of `account` by reading into the System crate Account storage
///
/// `account` Account identifier to retrieve value of
pub fn account_info(
    ArgsAccountInfo { url, account }: ArgsAccountInfo,
) -> Option<AccountInfo> {
    let account_id = AccountId32::from_string(&account)
        .expect("must be a valid ss58check format");
    let api = Api::new(&url).unwrap();
    let account_info = api.get_account_info(&account_id).unwrap();

    if let Some(account_info) = account_info {
        Some(AccountInfo {
            nonce: account_info.nonce,
            consumers: account_info.consumers,
            providers: account_info.providers,
            sufficients: account_info.sufficients,
            data: AccountData {
                free: BigNumber::from_u128(account_info.data.free).unwrap(),
                reserved: BigNumber::from_u128(account_info.data.reserved)
                    .unwrap(),
                misc_frozen: BigNumber::from_u128(
                    account_info.data.misc_frozen,
                )
                .unwrap(),
                fee_frozen: BigNumber::from_u128(account_info.data.fee_frozen)
                    .unwrap(),
            },
        })
    } else {
        None
    }
}

/// Get the `nonce` for this account.
/// `nonce` are used for composing a payload derived from a call.
/// Helper function that extracts the nonce from account info
pub fn get_nonce_for_account(
    ArgsGetNonceForAccount { url, account }: ArgsGetNonceForAccount,
) -> Option<u32> {
    let account_id = AccountId32::from_ss58check(&account)
        .expect("must be a valid ss58check format");
    Api::new(&url)
        .ok()
        .map(|api| api.get_nonce_for_account(&account_id).ok())
        .flatten()
}

/// Get the index of the pallet and the call/function name.
/// It returns [u8;2], but since graphql don't support this type, we convert the type
/// to a Vec<u8> of 2 elements, the element in index `0` is the pallet index.
/// The element in index `1` is the call/function index.
pub fn pallet_call_index(
    ArgsPalletCallIndex { url, pallet, call }: ArgsPalletCallIndex,
) -> Option<Vec<u8>> {
    Api::new(&url)
        .ok()
        .map(|api| {
            api.pallet_call_index(&pallet, &call)
                .ok()
                .map(|v| v.to_vec())
        })
        .flatten()
}

/// Sign an extrinsic payload
/// A wrapper around the signer-provider wrapper
pub fn sign(
    ArgsSign { extrinsic }: ArgsSign,
) -> Option<SignedExtrinsicPayload> {
    let res = SignerProviderModule::sign_payload(
        &signer_provider_module::ArgsSignPayload {
            payload: extrinsic.clone(),
        },
    )
    .unwrap();

    Some(SignedExtrinsicPayload {
        extrinsic,
        signature: res.signature,
    })
}

/// Send a signed extrinsic payload to the give RPC URL
pub fn send(
    ArgsSend {
        url,
        signed_extrinsic,
    }: ArgsSend,
) -> Option<String> {
    let encoded_extrinsic = UncheckedExtrinsicV4::try_from(signed_extrinsic)
        .unwrap()
        .hex_encode();

    let api = BaseApi::new(&url);
    let res = api.author_submit_extrinsic(encoded_extrinsic).unwrap();

    match res {
        Some(res) => Some(format!("{:#x}", res)),
        None => panic!("api.author_submit_extrinsic() returned None"),
    }
}

/// Sign an unsigned extrinsic payload and then immedietly send it
/// to the RPC. This is a common operation and saves a roundtrip
pub fn sign_and_send(
    ArgsSignAndSend { url, extrinsic }: ArgsSignAndSend,
) -> Option<String> {
    let result = SignerProviderModule::sign_payload(
        &signer_provider_module::ArgsSignPayload {
            payload: extrinsic.clone(),
        },
    )
    .unwrap();
    let signed_extrinsic = SignedExtrinsicPayload {
        extrinsic,
        signature: result.signature,
    };

    BaseApi::new(&url)
        .author_submit_extrinsic(
            UncheckedExtrinsicV4::try_from(signed_extrinsic)
                .unwrap()
                .hex_encode(),
        )
        .ok()
        .flatten()
        .map(|hash| format!("{:#x}", hash))
}

/// Create signed extrinsic.
pub fn create_signed(
    ArgsCreateSigned {
        url,
        signer,
        pallet_name,
        call_name,
        args,
    }: ArgsCreateSigned,
) -> Option<String> {
    let api = Api::new(&url).ok()?;
    let base_api = BaseApi::new(&url);
    let account_id = AccountId32::from_ss58check(&signer)
        .expect("must be a valid ss58check format");

    // 1. SCALE encode call data to bytes (pallet u8, call u8, call params).
    let call_data = {
        let mut out = vec![];
        let [pallet_index, call_name] = api
            .pallet_call_index(&pallet_name, &call_name)
            .expect("Unknown call.");
        let call_params = hex::decode(args.trim_start_matches("0x"))
            .expect("Failed to decode call data");

        pallet_index.encode_to(&mut out);
        call_name.encode_to(&mut out);
        Encoded(call_params).encode_to(&mut out);

        Encoded(out)
    };

    // 2. Construct our custom additional/extra params.
    let additional_and_extra_params = {
        let runtime = base_api.fetch_runtime_version().ok().flatten()?;
        let genesis_hash = base_api.fetch_genesis_hash().ok().flatten()?;
        let nonce = api.get_nonce_for_account(&account_id).ok()?;
        ExtrinsicParams::new(
            nonce,
            runtime.spec_version,
            runtime.transaction_version,
            genesis_hash,
            None,
            None,
            None,
        )
    };

    // 3. Construct signature. This is compatible with the Encode impl
    //    for SignedPayload (which is this payload of bytes that we'd like)
    //    to sign. See:
    //    https://github.com/paritytech/substrate/blob/9a6d706d8db00abb6ba183839ec98ecd9924b1f8/primitives/runtime/src/generic/unchecked_extrinsic.rs#L215)
    let signature = {
        let mut bytes = Vec::new();
        call_data.encode_to(&mut bytes);
        additional_and_extra_params.encode_extra_to(&mut bytes);
        additional_and_extra_params.encode_additional_to(&mut bytes);

        let data = if bytes.len() > 256 {
            sp_core::blake2_256(&bytes).to_vec()
        } else {
            bytes
        };

        let sig = SignerProviderModule::sign_raw(&signer_provider_module::ArgsSignRaw {
            payload: SignerProviderSignerPayloadRaw {
                _type: "bytes".into(),
                address: signer,
                data: hex::encode(data),
            },
        })
        .expect("Failed to sign extrinsic.")
        .signature;

        let mut sr25519_sig = [0; 64];
        sr25519_sig.copy_from_slice(&hex::decode(sig.trim_start_matches("0x")).expect("Invalid signature"));
        MultiSignature::Sr25519(Signature(sr25519_sig))
    };

    polywrap_wasm_rs::debug_log::wrap_debug_log(&format!("signature: {}", hex::encode(&signature.encode())));

    // 4. Encode extrinsic, now that we have the parts we need. This is compatible
    //    with the Encode impl for UncheckedExtrinsic (protocol version 4).
    let extrinsic = {
        let mut encoded_inner = Vec::new();
        // "is signed" + transaction protocol version (4)
        (0b10000000 + 4u8).encode_to(&mut encoded_inner); // y
        // from address for signature
        MultiAddress::Id(account_id).encode_to(&mut encoded_inner); // n
        // the signature bytes
        signature.encode_to(&mut encoded_inner);
        // attach custom extra params
        additional_and_extra_params.encode_extra_to(&mut encoded_inner);
        // and now, call data
        call_data.encode_to(&mut encoded_inner);
        // now, prefix byte length:
        let len = Compact(
            u32::try_from(encoded_inner.len())
                .expect("extrinsic size expected to be <4GB"),
        );
        let mut encoded = Vec::new();
        len.encode_to(&mut encoded);
        encoded.extend(encoded_inner);
        encoded
    };

    Some(format!("0x{}", hex::encode(extrinsic)))
}

/// Submit a signed extrinsic payload to the give RPC URL
pub fn submit(
    ArgsSubmit {
        url,
        signed_extrinsic,
    }: ArgsSubmit,
) -> Option<String> {
    let api = BaseApi::new(&url);
    let res = api.author_submit_extrinsic(signed_extrinsic).unwrap();

    res.map(|res| format!("{:#x}", res))
}
